## Web SDK API integration

The MyID Web SDK is a plug-and-play way for your web application to use MyID liveness verification inside the client's browser.

In this document, "Client" is you, the MyID customer - implementing "Client Backend" and "Client Frontend". "User" is the person going through the flow. "Server" is the
MyID liveness server web solution API.

There are two ways to integrate with the SDK.

### A. Redirect flow

Client Backend sends a request to the Server to issue a session ID. This session ID then is used to form a redirect URL,
and User is redirected to this redirect URL, leaving the Client Frontend.
Client Backend then is able to make periodic requests to the Server check the state of the session.
After the User is finished with the verification (whether succesful or not), their browser
is redirected back to the Client Frontend according to the provided and registered URL for the Client, after which the session ID is invalidated.

### B. Iframe flow

Same as redirect flow, except the web solution is embedded inside the client's website.
This is slightly less secure, but can be done if you want better UX. You will be asked to place additional code on 
your Client Frontend to facilitate some iframe communication. The session ID generated by the Client Backend is sent to Client Frontend,
which then forms the <iframe> source URL for the iframe to load within your page. After identification,
instead of a redirect, Client Frontend will receive data via `postMessage` from the iframe,
the listener for which you need to register with the provided example code. Same as redirect flow, you need to make serverside requests to check the session status.

## Protocol

Here you can download the OpenAPI specification for the protocol: [openapi.json]()

1.  `POST /api/v1/oauth2/access-token`
    Content-Type: `application/x-www-form-urlencoded`
    Body:

    ```
    grant_type=client_credentials
    client_id="**********"
    client_secret="**********"
    ```

    The token is stored and refreshed as needed.

2.  `POST /api/v1/web/sessions`
    Content-Type: `application/json`
    Headers: `Authorization: Bearer {access_token}`
    These headers should be present for all subsequent requests.

    Body:

    ```
    {
    	max_retries: Number,
    	external_id: String,
    	ip_address: String,
    }
    ```

    `max_retries`: the amount of times User can fail and retry liveness verification.
    `external_id`: an unique id of the session/user in your system, generated or stored by you, for session tracking purposes
    `ip_address`: the IP address of the user as seen by your server

    This request is used to create an identification session. The received `session_id` then needs to be handed off to the Web SDK.

3.  `https://web.myid.uz/?...`
    Redirect to/embed the Web SDK.

    Query parameters:
    `session_id`
    `pinfl`: PINFL of the user, or
    `pass_data`: passport of the user
    `birth_date`: in the format of "2000-12-31"
    `redirect_uri`: your callback URL as registered in MyID

    Example:

    ```
    	301 https://web.myid.uz/?session_id=ea56c1cb-ca1f-4fc0-b89e-185983877592&redirect_uri=https://myid.uz&pinfl=30101003300128&birth_date=2000-01-01`
    ```

        or

    ```html
    <iframe
    	src="https://web.myid.uz/?session_id=ea56c1cb-ca1f-4fc0-b89e-185983877592&redirect_uri=https://myid.uz&pinfl=30101003300128&birth_date=2000-01-01"
    	allow="camera;fullscreen"
    	allowfullscreen
    	border="0"
    	width="100%"
    	height="100%"
    ></iframe>
    ```

4.  `POST /api/v1/web/sessions/{{session_id}}/result`
    Content-Type: `application/json`

    Body:

    ```json
    {
    	"external_id": "..."
    }
    ```

    `external_id`: the same as submitted in the previous step.
    This request needs to be repeated from the backend until the status of the identification session changes.

-   `POST /api/v1/web/sessions/{{session_id}}/close`
    You can use this endpoint to forcibly close the session from your side if needed. The client flow will be immedately stopped with an error code and the client will be forwarded to `redirect_uri`.

## Iframe messaging

In order to receive events from the iframe once it's embedded in your page, the following example code can be used:

```js
const MyIDStatus = {
	EXCEPTION: -1,
	IN_PROGRESS: 0,
	LIVENESS_PASSED: 1,
	LIVENESS_FAILED: 2,
	RETRY: 3,
};

window.addEventListener("message", (e) => {
	if (e.data.source != "MyIDWebSDK") return;
	switch (e.data.status) {
		case MyIDStatus.EXCEPTION:
			console.error("MyID Iframe failed to load properly or a runtime error occurred.", e.data.error);
			break;
		case MyIDStatus.IN_PROGRESS:
			console.log("Client interacted with the iframe.");
			break;
		case MyIDStatus.LIVENESS_PASSED:
			console.log(e.data);
			yourSuccessCallback(e.data);
			break;
		case MyIDStatus.LIVENESS_FAILED:
			console.log(e.data.error_code, e.data.message);
			yourFailCallback(e.data);
			break;
		case MyIDStatus.RETRY:
			console.log("Client is trying again.");
			break;
		default:
			console.log("Unknown status:", e.data);
	}
});
```

This approach allows you to react to events from the iframe for UX purposes.

!> DO NOT trust these messages to determine if the liveness check passed or failed. 
Use them only as frontend events; afterwards, ALWAYS send a request 
from your backend to check the actual status.

Additionally, the following code MUST be present for the iframe to work correctly:

```js
const myidIframe = document.getElementById("myid_iframe"); // reference to the DOM node in your markup

function screenChangeListener(e) {
	iframe.contentWindow.postMessage(
		{
			cmd: "screen",
			screen: window.screen,
			height: window.innerHeight,
			width: window.innerWidth,
		},
		"*"
	);
}

myidIframe.addEventListener("load", screenChangeListener);
document.addEventListener("resize", screenChangeListener);

//cleanup (if using a frontend framework with mountable/unmountable views)

myidIframe.removeEventListener("load", screenChangeListener);
document.removeEventListener("resize", screenChangeListener);
```

## Customization

For security reasons, you cannot set any custom styling on the frontend side. To do so, you need to set customization options in your MyID account. Here's what you can customize:

-   Your logo
-   The primary color
-   Replace the font (base64)
-   Your phone number in error messages within the Web SDK
